./Aromodel.py:    Solvent.Set_Up_FF(run_orca=True, local = False)
./Configure.py:Orca_Path = "/oasis/scratch/comet/cjpais/temp_project/programs/orca_3_0_3_linux_x86-64/orca"
./DA_Main.py:    Solvent.Set_Up_FF(run_orca=True)
./Main.py:    Solvent.Set_Up_FF(run_orca=True, local = False)
./Molecule.py:    def Set_Up_FF(self, run_orca=True, local= True):
./Molecule.py:        if run_orca:
./Molecule.py:                    os.system('/Users/andrewkleinschmidt/Library/Orca/orca %s > %s' %(File_Name, File_Out)) # Run Orca Job
./Molecule.py:                subtemp = Configure.Template_Path + "sub_orca_temp"
./Molecule.py:                submit = "submit_orca"
./Molecule.py:        if not run_orca:
./Molecule.py:                    os.system('/Users/andrewkleinschmidt/Library/Orca/orca %s > %s' %(File_Name, File_Out)) # Run Orca Job
./Molecule.py:                subtemp = Configure.Template_Path + "sub_orca_temp"
./Molecule.py:                submit = "submit_orca"
./Molecule.py:                    os.system('/Users/andrewkleinschmidt/Library/Orca/orca %s > %s' %(File_Name, File_Out)) # Run Orca Job
./Ring.py:        Executable_Location = "/home/andrewk/orca_4_2_0_linux_x86-64_openmpi314"
./Ring.py:        Executable_Location = "/home/andrewk/orca_4_2_0_linux_x86-64_openmpi314"
./Write_Submit_Script.py:	f.write('export PATH=%s:%s/bin:$PATH\nexport RSH_COMMAND="/usr/bin/ssh -x"\nexport LD_LIBRARY_PATH=%s/lib\n%s/orca %s >> %s.out\n' % (OMP_Path,Executable_Path,OMP_Path,Executable_Path,In_File,Name))
./Write_Submit_Script.py:	f.write('orca %s >> %s.out\n' % (In_File,Name))
./aromodel_lib.py:    Executable_Location = "/home/andrewk/orca_4_2_0_linux_x86-64_openmpi314"
./Cluster_IO.py:def Quantum_Orca(file):
./Cluster_IO.py:#Returns True if an Orca job has finished running, and False if not
./Cluster_IO.py:def Opt_Orca(file):
./Cluster_IO.py:#Returns True if an Orca job has finished running, and False if not
./Cluster_IO.py:def Energy_Orca(Analyze_File,Folder_Name):
./Cluster_IO.py:#Returns the single point energy in kcal/mol for an Orca calculation
./Cluster_IO.py:def Loewdin_Charges_Orca(Analyze_File,Folder_Name):
./Cluster_IO.py:#Returns the Loewdin point charges for each atom for an Orca calculation
./Cluster_IO.py:			if End_Condition == "SPE_Orca":
./Cluster_IO.py:				if Quantum_Orca("./%s/%s" % (Folder_Name,Analyze_File)):
./Cluster_IO.py:			if End_Condition == "Opt_Orca":
./Cluster_IO.py:				if Opt_Orca("./%s/%s" % (Folder_Name,Analyze_File)):
./Cluster_IO.py:			if End_Condition == "SPE_Orca":
./Cluster_IO.py:				if Quantum_Orca("%s/%s" % (Shared_File_Location,Analyze_File)):
./Cluster_IO.py:			if End_Condition == "Opt_Orca":
./Cluster_IO.py:				if Opt_Orca("./%s/%s" % (Folder_Name,Analyze_File)):
./Cluster_IO.py:				if End_Condition == "SPE_Orca":
./Cluster_IO.py:					if Quantum_Orca("./%s/%s" % (Folder_Name,Analyze_File)):
./Cluster_IO.py:				if End_Condition == "Opt_Orca":
./Cluster_IO.py:					if Opt_Orca("./%s/%s" % (Folder_Name,Analyze_File)):
./Cluster_IO.py:			if End_Condition == "SPE_Orca":
./Cluster_IO.py:				if Quantum_Orca("./%s/%s" % (Folder_Name,Analyze_File)):
./Cluster_IO.py:			if End_Condition == "Opt_Orca":
./Cluster_IO.py:				if Opt_Orca("./%s/%s" % (Folder_Name,Analyze_File)):
./Cluster_IO.py:			if End_Condition == "SPE_Orca":
./Cluster_IO.py:				if Quantum_Orca("%s/%s" % (Shared_File_Location,Analyze_File)):
./Cluster_IO.py:			if End_Condition == "Opt_Orca":
./Cluster_IO.py:				if Opt_Orca("./%s/%s" % (Folder_Name,Analyze_File)):
./Cluster_IO.py:				if End_Condition == "SPE_Orca":
./Cluster_IO.py:					if Quantum_Orca("./%s/%s" % (Folder_Name,Analyze_File)):
./Cluster_IO.py:				if End_Condition == "Opt_Orca":
./Cluster_IO.py:					if Opt_Orca("./%s/%s" % (Folder_Name,Analyze_File)):
./Cluster_IO.py:	#Checks to see whether a job has already been completed, and if not submits a job to the cluster/supercomputer. Takes in: Copy_File_List: A List of files to be copied to the supercomputer to make the job run (usually a submit script, input file, and possible a data file), include path from ./ if in a subfolder; Folder_Name: The subdirectory to write all files to on the cluster/supercomputer and the shared folder; Submit_Script: script script file name (include path from ./ if in a subfolder); End_File: The script that will be output at the end of the run (for MD run, usually a data file with the final positions; for quantum file, the output file); Job_Name: the local location to copy files to. Will be made as a subdirectory under ./; Cluster_Login: String specifying your login for the cluster/supercomputer (e.g. yourname@comet.sdsc.edu); Cluster_Location: String specifying the folder to copy files to/from on the cluster; Base_Cluster_Location: String specifying cluster location for project as a whole; End_Condition: Optional string indicating if there is a special end condition that must be met or else resubmit the job. Options include "Quantum_Orca","Quantum_QChem", and "Quantum_NWChem" (checks that calculation converged and terminated for each quantum chemistry packaged); Analyze_File: The output file that will be parsed to get relevant information, required if End_Condition is defined; Shared_File_Location: String indicating a location where files can be shared between different runs of the program. Particularly useful for quantum calculations to avoid rerunning calculations between identical rings; Force_Copy: Boolean variable that if True forces the program to recopy from the cluster/supercomputer even if the file already exists locally; Force_New_Job: Boolean variable that if True forces the program to recopy from the cluster/supercomputer even if the job has already been run
./Cluster_IO.py:def Return_Info(Analyze_File,End_File,Folder_Name,Job_Name,Cluster_Login,Cluster_Location,Symmetry_Analyze_File = "",Symmetry_End_File = "",End_Condition = "",Shared_File_Location = "",Return_Energy_Orca = False,Return_Loewdin_Charges_Orca = False,Return_Energy_QChem = False,Return_NBO_Charges_QChem=False,Return_Energy_NWChem = False,Return_Averaged_Energy_Lammps = False,Return_ChelpG_Charges_QChem = False,Start_Point = 0):
./Cluster_IO.py:	#Checks for completed runs from the cluster/supercomputer and returns desired values. Takes in: Analyze_File: The file which will be used to return values from (may be the same as End_File); End_File: The script that will be output at the end of the run (for MD run, usually a data file with the final positions; for quantum file, the output file); Folder_Name: the local location to copy files to. Will be made as a subdirectory under ./; Cluster_Login: String specifying your login for the cluster/supercomputer (e.g. yourname@comet.sdsc.edu); Cluster_Location: String specifying the folder to copy files to/from on the cluster; End_Condition: Optional string indicating if there is a special end condition that must be met or else resubmit the job. Options include "Quantum_Orca","Quantum_QChem", and "Quantum_NWChem" (checks that calculation converged and terminated for each quantum chemistry packaged); Shared_File_Location: String indicating a location where files can be shared between different runs of the program. Particularly useful for quantum calculations to avoid rerunning calculations between identical rings; The Return flags each are boolean values which, if True, make the function return the requested value for the requested program (e.g. Return_Energy_Orca will return the single point energy from an Orca output file). Values are always returned in a tuple in the same order as the flags are listed above.
./Cluster_IO.py:				if End_Condition == "Quantum_Orca":
./Cluster_IO.py:					if Quantum_Orca("./%s/%s" % (Folder_Name,End_File)):
./Cluster_IO.py:				elif End_Condition == "Opt_Orca":
./Cluster_IO.py:					if Opt_Orca("./%s/%s" % (Folder_Name,End_File)):
./Cluster_IO.py:	if Return_Energy_Orca:
./Cluster_IO.py:		Return_Values.append(Energy_Orca(Analyze_File,Folder_Name))
./Cluster_IO.py:	if Return_Loewdin_Charges_Orca:
./Cluster_IO.py:		Return_Values.append(Loewdin_Charges_Orca(Analyze_File,Folder_Name))
./Cluster_IO.py:def Return_Info_Batch(Analyze_File_List,End_File_List,Folder_Name,Job_Name,Cluster_Login,Cluster_Location,Symmetry_Analyze_File = "",Symmetry_End_File = "",End_Condition = "",Shared_File_Location = "",Return_Energy_Orca = False,Return_Loewdin_Charges_Orca = False,Return_Energy_QChem = False,Return_NBO_Charges_QChem=False,Return_Energy_NWChem = False,Return_Averaged_Energy_Lammps = False,Return_ChelpG_Charges_QChem = False,Start_Point = 0):
./Cluster_IO.py:	#Checks for completed runs from the cluster/supercomputer and returns desired values. Takes in: Analyze_File: The file which will be used to return values from (may be the same as End_File); End_File: The script that will be output at the end of the run (for MD run, usually a data file with the final positions; for quantum file, the output file); Folder_Name: the local location to copy files to. Will be made as a subdirectory under ./; Cluster_Login: String specifying your login for the cluster/supercomputer (e.g. yourname@comet.sdsc.edu); Cluster_Location: String specifying the folder to copy files to/from on the cluster; End_Condition: Optional string indicating if there is a special end condition that must be met or else resubmit the job. Options include "Quantum_Orca","Quantum_QChem", and "Quantum_NWChem" (checks that calculation converged and terminated for each quantum chemistry packaged); Shared_File_Location: String indicating a location where files can be shared between different runs of the program. Particularly useful for quantum calculations to avoid rerunning calculations between identical rings; The Return flags each are boolean values which, if True, make the function return the requested value for the requested program (e.g. Return_Energy_Orca will return the single point energy from an Orca output file). Values are always returned in a tuple in the same order as the flags are listed above.
./Cluster_IO.py:					if End_Condition == "Quantum_Orca":
./Cluster_IO.py:						if Quantum_Orca("./%s/%s" % (Folder_Name,End_File)):
./Cluster_IO.py:					elif End_Condition == "Opt_Orca":
./Cluster_IO.py:						if Opt_Orca("./%s/%s" % (Folder_Name,End_File)):
./Cluster_IO.py:		if Return_Energy_Orca:
./Cluster_IO.py:			Value_List.append(Energy_Orca(Analyze_File,Folder_Name))
./Cluster_IO.py:	if Return_Energy_Orca:
./Cluster_IO.py:		if Return_Loewdin_Charges_Orca:
./Cluster_IO.py:			Value_List.append(Loewdin_Charges_Orca(Analyze_File,Folder_Name))
./Cluster_IO.py:	if Return_Loewdin_Charges_Orca:
./Configure.py:Orca_Path = "/oasis/scratch/comet/cjpais/temp_project/programs/orca_3_0_3_linux_x86-64/orca"
./DA_Polymer.py:        unConverged = Flag for bypassing Orca convergence (Default = False)
./Molecule.py:        UnConverged = Flag for bypassing Orca convergence (Default = False)
./Molecule.py:        self.UnConverged = True # Unconverged Orca Optimization
./Molecule.py:            print "Setting up Orca input script"
./Molecule.py:            # Write Orca Input File
./Molecule.py:                os.system('mkdir Orca')
./Molecule.py:                os.system('mv %s ./Orca' % File_Name)
./Molecule.py:                os.chdir('./Orca')
./Molecule.py:                    os.system('/Users/andrewkleinschmidt/Library/Orca/orca %s > %s' %(File_Name, File_Out)) # Run Orca Job
./Molecule.py:                print "Running Orca Geometry Optimization on Comet"
./Molecule.py:                s = template.format(Comet_Path=Path, Orca_Path = Configure.Orca_Path, name = self.Name )
./Molecule.py:            os.chdir('./Orca')
./Molecule.py:        # Extract info from Orca output file
./Molecule.py:        Orca_File = open(File_Out, 'r')
./Molecule.py:        File_Lines = Orca_File.readlines()
./Molecule.py:            # Write Orca Input File
./Molecule.py:                print "Running Orca on local machine"
./Molecule.py:                os.system('cd Orca')
./Molecule.py:                    os.system('/Users/andrewkleinschmidt/Library/Orca/orca %s > %s' %(File_Name, File_Out)) # Run Orca Job
./Molecule.py:                print "Running Orca Dihedral Scan %d on Comet" % i
./Molecule.py:                    s = template.format(Comet_Path=Path, Orca_Path = Configure.Orca_Path, name = Dihedral_Name )
./Molecule.py:                    os.system('/Users/andrewkleinschmidt/Library/Orca/orca %s > %s' %(File_Name, File_Out)) # Run Orca Job
./Molecule.py:                    s = template.format(Comet_Path=Path, Orca_Path = Configure.Orca_Path, name= MP2_Name)
./OPLS.py:    print "Bond #, Orca eq, OPLS eq"
./OPLS.py:    print "Angle #, Orca eq, OPLS eq"
./OPLS.py:        print "Bond #, Orca eq, OPLS eq"
./OPLS.py:        print "Angle #, Orca eq, OPLS eq"
./Ring.py:    def Update_Positions_Orca_Output(self,Orca_Output_File,Hydrogenated=False):
./Ring.py:        f = open(Orca_Output_File,'r')
./Ring.py:    def Update_Positions_Orca_Output_Hydrogenated(self,Orca_Output_File):
./Ring.py:        f = open(Orca_Output_File,'r')
./Ring.py:    def Set_Up_Bonds(self,Orca_Output_File):
./Ring.py:        f = open(Orca_Output_File,'r')
./Ring.py:        Job_Type = "Orca"
./Ring.py:        End_Condition = "Opt_Orca"
./Ring.py:        Write_Inputs.Write_Orca_Optimize_Geometry(In_File,Monomer,H_Only = True)
./Ring.py:        self.Update_Positions_Orca_Output("./Optimized_Monomers/%s" % End_File)
./Ring.py:        #self.Update_H_Positions_Orca("./Optimized_Monomers/%s" % Log_File)
./Ring.py:        Job_Type = "Orca"
./Ring.py:        End_Condition = "Opt_Orca"
./Ring.py:        Write_Inputs.Write_Orca_Optimize_Geometry(In_File,Monomer,H_Only = True)
./Ring.py:        self.Update_Positions_Orca_Output_Hydrogenated("./Optimized_Monomers/%s" % End_File)
./Write_Inputs.py:def Write_Orca_SPE(File_Name,Test_Molecule,Method = "RI-MP2",Basis = "cc-pVTZ",Aux_Basis = "cc-pVTZ/C",convergence = "NORMALSCF",nproc = 4,Implicit_Solvent = "CPCM(Chloroform)",Memory = 3000):
./Write_Inputs.py:def Write_Orca_Optimize_Geometry(File_Name,Test_Molecule,Method = "RI BP86",Basis = "def2-SVP",Aux_Basis = "def2/J",Dispersion_Correction = "D3BJ",convergence = "TIGHTSCF",nproc = 1,Memory = 3000,H_Only = False,Planarize = False,Planarize_Atoms = [],Aux_Torsions1 = [],Aux_Torsions2 = [],Bond_Eq = 0.0,Bond_Atoms = []):
./Write_Inputs.py:def Write_Orca_ChelpG(File_Name,Test_Molecule,Method = "RI BP86",Basis = "def2-SVP",Aux_Basis = "def2/J",Dispersion_Correction = "D3BJ",convergence = "TIGHTSCF",nproc = 4,Memory = 3000,H_Only = False,Planarize = False,Planarize_Atoms = []):
./Write_Submit_Script.py:def Write_Orca(f,nproc,In_File,Name,Executable_Path,OMP_Path):
./Write_Submit_Script.py:def Write_Orca_Run_Only(f,nproc,In_File,Name,Executable_Path,OMP_Path):
./Write_Submit_Script.py:	if Job_Type == "Orca":
./Write_Submit_Script.py:			raise Exception("Executable_Path required for Orca")
./Write_Submit_Script.py:			raise Exception("OMP_Path required for Orca")
./Write_Submit_Script.py:		Write_Orca(f,nproc,In_File,Name,Executable_Path,OMP_Path)
./Write_Submit_Script.py:	if Job_Type == "Orca":
./Write_Submit_Script.py:			raise Exception("Executable_Path required for Orca")
./Write_Submit_Script.py:			raise Exception("OMP_Path required for Orca")
./Write_Submit_Script.py:			Write_Orca(f,nproc,In_File,Name,Executable_Path,OMP_Path)
./Write_Submit_Script.py:	if Job_Type == "Orca":
./Write_Submit_Script.py:			raise Exception("Executable_Path required for Orca")
./Write_Submit_Script.py:			raise Exception("OMP_Path required for Orca")
./Write_Submit_Script.py:		Write_Orca(f,nproc,In_File,Name,Executable_Path,OMP_Path)
./aromodel_lib.py:    Job_Type = "Orca"
./aromodel_lib.py:    End_Condition = "Opt_Orca"
./aromodel_lib.py:        Write_Inputs.Write_Orca_Optimize_Geometry(In_File,Stretch,Bond_Eq = Bond_Eq,Bond_Atoms = [Bonded_Atom_List[0].Atom_ID,Bonded_Atom_List[1].Atom_ID])
